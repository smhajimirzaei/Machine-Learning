{"title":"Clustering","markdown":{"yaml":{"title":"Clustering","author":"Morteza Mirzaei","date":"2023-12-09","categories":["code","analysis"],"image":"image.png"},"headingText":"Clustering","containsRefs":false,"markdown":"\n\n\nIn this study, two non-contact velocity meters (Doppler LiDAR sensors) are mounted onboard a hi-rail vehicle and measured and stored the lateral vibration of both rails (right and left). The test is about 3.2 miles.\n\nSeveral steps had been taken which will non be discusseed here. In nutshel,\n\n-   Data cleaning\n\n-   Scaling the velocities\n\n-   High-pass filtering\n\n-   Solve for homoscedasticity\n\n-   And finally segmenting since we want to look at section of track not a single data point\n\n![](images/f.png)\n\n``` python\nfrom google.colab import drive\ndrive.mount('/content/drive')\n```\n\n```         \nMounted at /content/drive\n```\n\n``` python\nimport pandas as pd\nimport numpy as np\nfrom sklearn import preprocessing\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\nfrom sklearn import preprocessing\nfrom sklearn.mixture import GaussianMixture\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import precision_recall_fscore_support as score\n```\n\n``` python\ndef interactive_plot_scatter(df, x_axis, y_axis):\n  import plotly.express as px\n\n  fig = px.scatter(df, x_axis, y_axis)\n  return fig.show()\n\ndef interactive_plot_line(df, x_axis, y_axis):\n  import plotly.express as px\n\n  fig = px.line(df, x_axis, y_axis)\n  return fig.show()\n\ndef tach_cleaning(df):\n  tach = np.zeros(df['Tach'].shape[0])\n  for i in range(1, df['Tach'].shape[0]):\n    if df.iloc[i]['Tach'] > 2.2:\n      tach[i] = 5\n  df['Tach_p'] = tach\n  return df\n\ndef position_string(df: dict) -> str:\n  df['Pos'] = 0.000000\n  pos = df['Pos']\n  c = 0;\n  delta = float((1/36) * 7.25 * np.pi / 12);\n  for i in range(1, pos.shape[0]):\n    if (np.abs(df.iloc[i]['Tach']-df.iloc[i-1]['Tach'])>1):\n      c = c + 1\n    pos[i] = delta * c\n  return pos\n\ndef remove_Keyence_dropout(df):\n  df = df[df['left_disp']<1.15]\n  df = df[df['right_disp']<0.925]\n  return df\n\ndef remove_outliers(df):\n  Q1 = np.percentile(df['right_disp'], 25,\n                   interpolation = 'midpoint')\n\n  Q3 = np.percentile(df['right_disp'], 75,\n                   interpolation = 'midpoint')\n  IQR = Q3 - Q1\n\n  up = Q3+1.5*IQR\n  low = Q1-1.5*IQR\n\n  df = df[df['right_disp']<up]\n  df = df[df['right_disp']>low]\n\n  Q1 = np.percentile(df['left_disp'], 25,\n                   interpolation = 'midpoint')\n\n  Q3 = np.percentile(df['left_disp'], 75,\n                   interpolation = 'midpoint')\n  IQR = Q3 - Q1\n\n  up = Q3+1.5*IQR\n  low = Q1-1.5*IQR\n\n  df = df[df['left_disp']<up]\n  df = df[df['left_disp']>low]\n  return df\n```\n\n``` python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef custom_multiplot(x, y_sets, title=None, xlabel=None, ylabel=None, legend_labels=None, legend_loc='best', grid=True, save_as=None, colors=None, title_size=16, label_font_size=12, tick_font_size=10, figsize=(10, 6), xlim=None, ylim=None, xlog=False, ylog=False, scatter=False):\n    \"\"\"\n    Create a customized plot with multiple y-axis parameters using Matplotlib.\n\n    Parameters:\n    - x: x-axis data (list or NumPy array)\n    - y_sets: List of y-axis data sets (list of lists or NumPy arrays)\n    - title: Plot title (string, optional)\n    - xlabel: Label for the x-axis (string, optional)\n    - ylabel: Label for the y-axis (string, optional)\n    - legend_labels: Labels for the legend (list of strings, optional)\n    - legend_loc: Location of the legend ('best', 'upper left', 'upper right', 'lower left', 'lower right', etc.)\n    - grid: Display grid lines (boolean, optional)\n    - save_as: File name to save the plot as an image (string, optional)\n    - colors: List of line colors (list of strings or tuples, optional)\n    - title_size: Font size for the plot title (int, optional)\n    - label_font_size: Font size for axis labels and legend (int, optional)\n    - tick_font_size: Font size for tick labels (int, optional)\n    - figsize: Figure size as a tuple (width, height) (optional)\n    - xlim: Tuple specifying the x-axis limits (e.g., (xmin, xmax)) (optional)\n    - ylim: Tuple specifying the y-axis limits (e.g., (ymin, ymax)) (optional)\n    - xlog: Enable logarithmic scaling for the x-axis (boolean, optional)\n    - ylog: Enable logarithmic scaling for the y-axis (boolean, optional)\n\n    Returns:\n    - None\n    \"\"\"\n    plt.figure(figsize=figsize)  # Adjust the figure size\n\n    if colors is None:\n        colors = ['blue', 'red', 'green', 'purple', 'orange', 'cyan', 'magenta']\n\n    for i, y in enumerate(y_sets):\n        color = colors[i % len(colors)]\n        label = legend_labels[i] if legend_labels and i < len(legend_labels) else None\n\n        if scatter:\n            plt.scatter(x, y, label=label, color=color, s=30)\n        elif xlog:\n            plt.semilogx(x, y, label=label, color=color, linewidth=2)\n        elif ylog:\n            plt.semilogy(x, y, label=label, color=color, linewidth=2)\n        else:\n            plt.plot(x, y, label=label, color=color, linewidth=2)\n\n    if legend_labels:\n        plt.legend(legend_labels, loc=legend_loc, fontsize=label_font_size)\n\n    if title:\n        plt.title(title, fontsize=title_size)\n\n    if xlabel:\n        plt.xlabel(xlabel, fontsize=label_font_size)\n\n    if ylabel:\n        plt.ylabel(ylabel, fontsize=label_font_size)\n\n    if grid:\n        plt.grid(True)\n\n    if xlim:\n        plt.xlim(xlim)\n\n    if ylim:\n        plt.ylim(ylim)\n\n    plt.xticks(fontsize=tick_font_size)\n    plt.yticks(fontsize=tick_font_size)\n\n    if xlog:\n        plt.xscale('log')\n    if ylog:\n        plt.yscale('log')\n    ax = plt.gca()\n    #ax.xaxis.set_major_locator(MaxNLocator(integer=True))\n    #ax.yaxis.set_major_locator(MaxNLocator(integer=True))\n    if save_as:\n        plt.savefig(save_as, dpi=300, bbox_inches='tight')\n\n    plt.show()\n#----------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\n\nIn the dataset we have two parameters. Fist one +2 sigma right/left velocity within the entire data and the other one is +2 sigma right/left velocity within each segment.\n\n``` python\ndf = pd.read_csv('/content/drive/MyDrive/ML/SLineNS2.csv')\n```\n\nIn here, we will only keep the maximum value of right or left rail for each parameter. The reason is that in this case if any of the left or right rail is loose it will mark it as loose.\n\n``` python\ndef max_FromAll(row):\n    return max(row['Right_Plus_2Sigma_FromAll_Lateral_Weighted'], row['Left_Plus_2Sigma_FromAll_Lateral_Weighted'])\ndef max_FromSegment(row):\n    return max(row['Right_Plus_2Sigma_FromSegment_Lateral_Weighted'], row['Left_Plus_2Sigma_FromSegment_Lateral_Weighted'])\n\n# Apply the function to create a new column 'max_value'\ndf['max_value_FromAll'] = df.apply(max_FromAll, axis=1)\ndf['max_value_FromSegment'] = df.apply(max_FromSegment, axis=1)\n```\n\n``` python\nX = df[['max_value_FromAll', 'max_value_FromSegment']]\nn_clusters = 4 # we need 5 clusters based on elbow method\n\ngmm = GaussianMixture(n_components=5, random_state=42)\ngmm.fit(X)\n```\n\n```         \nGaussianMixture(n_components=5, random_state=42)\n```\n\n``` python\ndf['Cluster'] = gmm.predict(X)\n```\n\n``` python\nsns.scatterplot(x='max_value_FromAll', y='max_value_FromSegment', hue='Cluster', data=df, palette=['green', 'red', 'purple', 'brown', 'blue'])\nplt.title('Gaussian Mixture Model Clustering')\nplt.show()\n```\n\n![](images/10.png){width=\"467\"}\n\n``` python\nsns.scatterplot(x='Segment', y='max_value_FromAll', hue='Cluster', data=df, palette=['green', 'red', 'purple', 'brown', 'blue'])\nplt.title('Gaussian Mixture Model Clustering')\nplt.show()\n```\n\n![](images/11.png){width=\"467\"}\n\n## Interpreting the results\n\nAfter inspecting all the clusters in Google map, Red cluster (only segment) turned out to be a railroad switch\n\n![](images/12.png){width=\"694\"}\n","srcMarkdownNoYaml":"\n\n# Clustering\n\nIn this study, two non-contact velocity meters (Doppler LiDAR sensors) are mounted onboard a hi-rail vehicle and measured and stored the lateral vibration of both rails (right and left). The test is about 3.2 miles.\n\nSeveral steps had been taken which will non be discusseed here. In nutshel,\n\n-   Data cleaning\n\n-   Scaling the velocities\n\n-   High-pass filtering\n\n-   Solve for homoscedasticity\n\n-   And finally segmenting since we want to look at section of track not a single data point\n\n![](images/f.png)\n\n``` python\nfrom google.colab import drive\ndrive.mount('/content/drive')\n```\n\n```         \nMounted at /content/drive\n```\n\n``` python\nimport pandas as pd\nimport numpy as np\nfrom sklearn import preprocessing\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n%matplotlib inline\nfrom sklearn import preprocessing\nfrom sklearn.mixture import GaussianMixture\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import precision_recall_fscore_support as score\n```\n\n``` python\ndef interactive_plot_scatter(df, x_axis, y_axis):\n  import plotly.express as px\n\n  fig = px.scatter(df, x_axis, y_axis)\n  return fig.show()\n\ndef interactive_plot_line(df, x_axis, y_axis):\n  import plotly.express as px\n\n  fig = px.line(df, x_axis, y_axis)\n  return fig.show()\n\ndef tach_cleaning(df):\n  tach = np.zeros(df['Tach'].shape[0])\n  for i in range(1, df['Tach'].shape[0]):\n    if df.iloc[i]['Tach'] > 2.2:\n      tach[i] = 5\n  df['Tach_p'] = tach\n  return df\n\ndef position_string(df: dict) -> str:\n  df['Pos'] = 0.000000\n  pos = df['Pos']\n  c = 0;\n  delta = float((1/36) * 7.25 * np.pi / 12);\n  for i in range(1, pos.shape[0]):\n    if (np.abs(df.iloc[i]['Tach']-df.iloc[i-1]['Tach'])>1):\n      c = c + 1\n    pos[i] = delta * c\n  return pos\n\ndef remove_Keyence_dropout(df):\n  df = df[df['left_disp']<1.15]\n  df = df[df['right_disp']<0.925]\n  return df\n\ndef remove_outliers(df):\n  Q1 = np.percentile(df['right_disp'], 25,\n                   interpolation = 'midpoint')\n\n  Q3 = np.percentile(df['right_disp'], 75,\n                   interpolation = 'midpoint')\n  IQR = Q3 - Q1\n\n  up = Q3+1.5*IQR\n  low = Q1-1.5*IQR\n\n  df = df[df['right_disp']<up]\n  df = df[df['right_disp']>low]\n\n  Q1 = np.percentile(df['left_disp'], 25,\n                   interpolation = 'midpoint')\n\n  Q3 = np.percentile(df['left_disp'], 75,\n                   interpolation = 'midpoint')\n  IQR = Q3 - Q1\n\n  up = Q3+1.5*IQR\n  low = Q1-1.5*IQR\n\n  df = df[df['left_disp']<up]\n  df = df[df['left_disp']>low]\n  return df\n```\n\n``` python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef custom_multiplot(x, y_sets, title=None, xlabel=None, ylabel=None, legend_labels=None, legend_loc='best', grid=True, save_as=None, colors=None, title_size=16, label_font_size=12, tick_font_size=10, figsize=(10, 6), xlim=None, ylim=None, xlog=False, ylog=False, scatter=False):\n    \"\"\"\n    Create a customized plot with multiple y-axis parameters using Matplotlib.\n\n    Parameters:\n    - x: x-axis data (list or NumPy array)\n    - y_sets: List of y-axis data sets (list of lists or NumPy arrays)\n    - title: Plot title (string, optional)\n    - xlabel: Label for the x-axis (string, optional)\n    - ylabel: Label for the y-axis (string, optional)\n    - legend_labels: Labels for the legend (list of strings, optional)\n    - legend_loc: Location of the legend ('best', 'upper left', 'upper right', 'lower left', 'lower right', etc.)\n    - grid: Display grid lines (boolean, optional)\n    - save_as: File name to save the plot as an image (string, optional)\n    - colors: List of line colors (list of strings or tuples, optional)\n    - title_size: Font size for the plot title (int, optional)\n    - label_font_size: Font size for axis labels and legend (int, optional)\n    - tick_font_size: Font size for tick labels (int, optional)\n    - figsize: Figure size as a tuple (width, height) (optional)\n    - xlim: Tuple specifying the x-axis limits (e.g., (xmin, xmax)) (optional)\n    - ylim: Tuple specifying the y-axis limits (e.g., (ymin, ymax)) (optional)\n    - xlog: Enable logarithmic scaling for the x-axis (boolean, optional)\n    - ylog: Enable logarithmic scaling for the y-axis (boolean, optional)\n\n    Returns:\n    - None\n    \"\"\"\n    plt.figure(figsize=figsize)  # Adjust the figure size\n\n    if colors is None:\n        colors = ['blue', 'red', 'green', 'purple', 'orange', 'cyan', 'magenta']\n\n    for i, y in enumerate(y_sets):\n        color = colors[i % len(colors)]\n        label = legend_labels[i] if legend_labels and i < len(legend_labels) else None\n\n        if scatter:\n            plt.scatter(x, y, label=label, color=color, s=30)\n        elif xlog:\n            plt.semilogx(x, y, label=label, color=color, linewidth=2)\n        elif ylog:\n            plt.semilogy(x, y, label=label, color=color, linewidth=2)\n        else:\n            plt.plot(x, y, label=label, color=color, linewidth=2)\n\n    if legend_labels:\n        plt.legend(legend_labels, loc=legend_loc, fontsize=label_font_size)\n\n    if title:\n        plt.title(title, fontsize=title_size)\n\n    if xlabel:\n        plt.xlabel(xlabel, fontsize=label_font_size)\n\n    if ylabel:\n        plt.ylabel(ylabel, fontsize=label_font_size)\n\n    if grid:\n        plt.grid(True)\n\n    if xlim:\n        plt.xlim(xlim)\n\n    if ylim:\n        plt.ylim(ylim)\n\n    plt.xticks(fontsize=tick_font_size)\n    plt.yticks(fontsize=tick_font_size)\n\n    if xlog:\n        plt.xscale('log')\n    if ylog:\n        plt.yscale('log')\n    ax = plt.gca()\n    #ax.xaxis.set_major_locator(MaxNLocator(integer=True))\n    #ax.yaxis.set_major_locator(MaxNLocator(integer=True))\n    if save_as:\n        plt.savefig(save_as, dpi=300, bbox_inches='tight')\n\n    plt.show()\n#----------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\n\nIn the dataset we have two parameters. Fist one +2 sigma right/left velocity within the entire data and the other one is +2 sigma right/left velocity within each segment.\n\n``` python\ndf = pd.read_csv('/content/drive/MyDrive/ML/SLineNS2.csv')\n```\n\nIn here, we will only keep the maximum value of right or left rail for each parameter. The reason is that in this case if any of the left or right rail is loose it will mark it as loose.\n\n``` python\ndef max_FromAll(row):\n    return max(row['Right_Plus_2Sigma_FromAll_Lateral_Weighted'], row['Left_Plus_2Sigma_FromAll_Lateral_Weighted'])\ndef max_FromSegment(row):\n    return max(row['Right_Plus_2Sigma_FromSegment_Lateral_Weighted'], row['Left_Plus_2Sigma_FromSegment_Lateral_Weighted'])\n\n# Apply the function to create a new column 'max_value'\ndf['max_value_FromAll'] = df.apply(max_FromAll, axis=1)\ndf['max_value_FromSegment'] = df.apply(max_FromSegment, axis=1)\n```\n\n``` python\nX = df[['max_value_FromAll', 'max_value_FromSegment']]\nn_clusters = 4 # we need 5 clusters based on elbow method\n\ngmm = GaussianMixture(n_components=5, random_state=42)\ngmm.fit(X)\n```\n\n```         \nGaussianMixture(n_components=5, random_state=42)\n```\n\n``` python\ndf['Cluster'] = gmm.predict(X)\n```\n\n``` python\nsns.scatterplot(x='max_value_FromAll', y='max_value_FromSegment', hue='Cluster', data=df, palette=['green', 'red', 'purple', 'brown', 'blue'])\nplt.title('Gaussian Mixture Model Clustering')\nplt.show()\n```\n\n![](images/10.png){width=\"467\"}\n\n``` python\nsns.scatterplot(x='Segment', y='max_value_FromAll', hue='Cluster', data=df, palette=['green', 'red', 'purple', 'brown', 'blue'])\nplt.title('Gaussian Mixture Model Clustering')\nplt.show()\n```\n\n![](images/11.png){width=\"467\"}\n\n## Interpreting the results\n\nAfter inspecting all the clusters in Google map, Red cluster (only segment) turned out to be a railroad switch\n\n![](images/12.png){width=\"694\"}\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","editor":"visual","theme":"cosmo","title-block-banner":true,"title":"Clustering","author":"Morteza Mirzaei","date":"2023-12-09","categories":["code","analysis"],"image":"image.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}